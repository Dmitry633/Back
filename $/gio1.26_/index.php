<?php
//Array funcs
require 'helper.php';
//array_chunk(( array $array , int $size [, bool $preserve_keys = false ]):array
// для разбиения массива на куски
$items = ['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5];
prettyPrintArray(array_chunk($items, 2, true));

//array_combine( array $keys , array $values ):array
//для объединения массивов - выдаст ошибку если число элементов первого массива неравно числу элементов второго
$array1 = ['a', 'b', 'c'];
$array2 = [5, 10, 15];
prettyPrintArray(array_combine($array1, $array2));

//array_filter( array $array [, callable $callback [, int $flag = 0 ]]) - перебирает каждый элемент массива и перердает значение в принимаемый колбэк, если ретерн колбэка тру, то значение возвращается в результирующий массив, в противном случае элемент будет сброшен

$array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
//оставим в массиве четные числа
$even = array_filter($array, fn($number) => $number % 2 === 0);// по умолчанию в качестве number используется значение из массива
prettyPrintArray($even);
$even = array_filter($array, fn($number) => $number % 2 === 0, ARRAY_FILTER_USE_KEY);// для использование ключа нужно добавить третий параметр
prettyPrintArray($even);
$even = array_filter($array, fn($number, $key) => $number % 2 === 0, ARRAY_FILTER_USE_BOTH);// здесь первый аргумент стрелочной ф-ции - значение, второй - ключ
prettyPrintArray($even);

$even = array_values($even);//для упорядовачивания индексов массива
prettyPrintArray($even);

//Если не указать колббэк в параметра, то будут отфильтрованы все фолс значения
$array = [1, 2, 3, false, 5, 0.0, 7, 0, 9, 10];
$even = array_filter($array);
prettyPrintArray($even);

//array_keys( array $array , mixed $search_value [, bool $strict ]):array - для вывода массива из ключей

$array = ['a' => 5, 'b' => 10, 'c' => 15, 'd' => '15', 'e' => 10];
$keys = array_keys($array);
prettyPrintArray($keys);
//или искать конкретные значения  и возвращать только ключи этих значений
$keys = array_keys($array, 15);
prettyPrintArray($keys);
//по дефолту в предлыдущих примерах было нестрогое сравнение, но третьим аргументом можног задать строгое.
$keys = array_keys($array, 15, true);
prettyPrintArray($keys);

//  array_map( callable $callback , array $array1 [, array $... ]):array - применяет колбэк к каждомуц элементу перерданного массива

$array = [1, 2, 3, 4, 5, 6];//хотим умножиь каждый элемент на 3
$array = array_map(fn($number) => $number * 3, $array);
prettyPrintArray($array);
// для с нескеоьких мвссивов:
$array1 = ['a' => 1, 'b' => 2, 'c' => 3];//
$array2 = ['d' => 4, 'e' => 5, 'f' => 6];//
$array = array_map(fn($number1, $number2) => $number1 * $number2, $array1, $array2);
prettyPrintArray($array);// ключи стали цифрами  тк  мы перердали больше одного массива
// Для нескольких array_map лучше применять массивы одинаковой длины, если будет роазная, то более короткий массив будет расширен пустыми элементами =  0
//Также можно передать null как колбэк - тогда все что будет сделано - это пострен массив из переданных массивов

//array_merge( array $array1 [, array $... ):array - позволяет сделать слияние нескольких массивов
// Если массивы имеют одинаковые численные ключи,то они не будут перезаписаны, вместо этого  он будут добавлены, также численные ключи будут перериндексованы начиная с 0
$array1 = [1, 2, 3];
$array2 = [4, 5, 6];
$array3 = [7, 8, 9];

$merged = array_merge($array1, $array2, $array3);
prettyPrintArray($merged);

$array1 = [1, 2, 3];
$array2 = ['a' => 4, 'b' => 5, 'c' =>6];// в этом случае строчные кключи не нумеруются
$array3 = [7, 8, 9];
$merged = array_merge($array1, $array2, $array3);
prettyPrintArray($merged);

$array1 = [1, 2, 3];
$array2 = ['a' => 4, 'b' => 5, 'c' =>6];// в этом случае значение 'b' будет перерзаписано и будет равно 10
$array3 = [7, 8, 9, 'b' => 10];
$merged = array_merge($array1, $array2, $array3);
prettyPrintArray($merged);

//array_reduce( array $array , callable $callback [, mixed $initial ]):mixed - уменьшает массив до одиночного значения , используя колбэк ф-цию, которую ты передал

$invoiceItems = [//напр нужно перермножить цену с кол-вом и проссумировать для получения общей стоимсоти
    ['price' => 9.99, 'qty' => 3, 'desc' => 'Item 1'],
    ['price' => 29.99, 'qty' => 1, 'desc' => 'Item 2'],
    ['price' => 149, 'qty' => 1, 'desc' => 'Item 3'],
    ['price' => 14.99, 'qty' => 2, 'desc' => 'Item 4'],
    ['price' => 4.99, 'qty' => 4, 'desc' => 'Item 5'],
];

$total = array_reduce(
    $invoiceItems, 
    fn($sum, $item) => $sum +$item['qty'] * $item['price'] //первый аргумент стрелочной ф-ции - это вовращенное значение предыдущей итерации, второй аргумент - это знаение в текущей итерации
);
//На каждой итерации, какое бы значение ни было возвращено, перердается как первый аргумент на следующую итерацию
 
echo $total ."\n";//258.9
//можно добавить третий аргумент - изщначальное значение первого аргумента в первой итерации (без него он  = 0)
$total = array_reduce(
    $invoiceItems, 
    fn($sum, $item) => $sum +$item['qty'] * $item['price'],
    500 
);
echo $total ."\n";//758.9

//array_search( mixed $needle , array $haystack [, bool $strict ]): int|string|false  - для поиска массивов

$array = ['a', 'b', 'c', 'D', 'E', 'ab', 'bc', 'cd', 'b', 'd'];
//вернем ключи первых совпавших значений. Найдем ключи буквы 'b'
$key = array_search('b', $array);//первый аргумент искомое, второй аргумент массив в котором ищем,третий аргумет - обозначает срогое или не строгое сравнение длеать при поиске

var_dump($key);//int(1) - находит только первое совпадение. Также такой поиск чуствителен к регистру
//В случае не нахождения вернет false, но также может вернуть 0 в случае если искомое на нулевой позиции, так чо слледуеьт быть осторожным при сравнении следует делать строгое сравнение напр
$key = array_search('a', $array);
var_dump($key);//int(0)

if ($key == false){
    echo 'Letter not found' ."\n";// но буква найдена, - нестрогое сравнение радотает некорректно
}

if ($key === false){
    echo 'Letter not found' ."\n";
} else {
    echo 'Letter found' ."\n";// но буква найдена, - нестрогое сравнение радотает некорректно
}

//Еще вариант поиска
if(! in_array('a', $array)){ //первый аргумент  -  искомое, второй массив в котором ищзем
    echo 'Letter not found' ."\n";
}
if(in_array('a', $array)){ //первый аргумент  -  искомое, второй массив в котором ищзем
    echo 'Letter found' ."\n";
}
//Для поиска отличий между массивами:
$array1 = ['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5];//
$array2 = ['d' => 4, 'g' => 5, 'i' => 6, 'j' => 7, 'k' => 8];
$array3 = ['l' => 3, 'm' => 9, 'n' => 10];

prettyPrintArray(array_diff($array1, $array2, $array3));// // сравнит первый массив с другими прееданными массивами и вернет значения из первого массива, которые не представлены в каком либо другом массиве. Результат:
// (
//     [a] => 1
//     [b] => 2
// )
//Примечание -ф-ция проверяет только значения, если нужно сравнимать ключи, то нужно использовать след ф-цию:
prettyPrintArray(array_diff_assoc($array1, $array2, $array3));
//Рез-т:
// (
//     [a] => 1
//     [b] => 2
//     [c] => 3
//     [e] => 5
// )
// Также для сравнения по ключам можно использовать
prettyPrintArray(array_diff_key($array1, $array2, $array3));

echo 'Для сортировки:'. "\n";
$array =['d' => 3, 'l' => 1, 'c' => 4, 'k' => 2];
prettyPrintArray($array);
asort($array);//сортирует по значениям
prettyPrintArray($array);
ksort($array);//сортирует по ключам
prettyPrintArray($array);
//Примечание: некоторые из этих ф-ций не возвращают новый массив, вметсо этого возвращают булиновое значение, и они принимают аргумент как ссылку, так. что это преобразует изначалную переменную
//Следующий полезный спопб сортровки:
//usort( array $array , callable $value_compare_func ) - можно передать пользовательский колбэк и сортироват его каким либо способом

usort($array, fn($a, $b) => $a <=> $b);//нам нужно вернуть ноль, если a = b, return -1 if a < b, return 1 if a > b - это можно сделать вручную, но есть оператор <=>
prettyPrintArray($array);

usort($array, fn($a, $b) => $b <=> $a);//сортировка в обратном направдлении
prettyPrintArray($array);//пользовательские ключи заменены на числа, т.к. так работает usort

echo 'Для разрушения  массива:' . "\n";
//Вы модете взять переменные  из вне массива или разобрать массив в отдельные переменные
$array = [1, 2, 3, 4];// мы можем разрушить массив и назначить их двумя перемнными в одну строчку
//list($a, $b, $c, $d) = $array;
[$a, $b, $c, $d] = $array;// то же самое, несомтря на то что list это не встроенная ф-ция, а является языковой конструкцией обратим на нее внимание

echo $a . ', ' .$b.', ' .$c.', ' .$d. "\n";//1, 2, 3, 4
// т.е мы рзарушили массив в отдельные переменные, также можно пропускать элементы простым удалением и исп-ем запятой
[$a, , $c, $d] = $array;
echo $a . ', ' .$c.', ' .$d. "\n";//1, 3, 4

//также возможно разрушить вложенный массив
$array = [1, 2, [3, 4]];
[$a, $b, [$c, $d]] = $array;
echo $a . ', ' .$b.', ' .$c.', ' .$d. "\n";//1, 2, 3, 4
//Также возможно назначит ключи
$array = [1, 2, 3];
[1 => $a, 0 => $b, 2 => $c] = $array;//т.е здесь мы указали ключи, назначаем переменным порядковый номер элемента разрушаемого массива  $a = 2 - -первый элемент массива, $b = 1 - нулевой пеэлемент массива, $c = 3 - второй элемнет массива
echo $a . ', ' .$b.', ' .$c. "\n";//2, 1, 3 - значения переменных // также это возможно сделать со строчными клюычами
//также есть много других ф-ций

//1.27 PHP.INI

//https://www.php.net/manual/en/ini.list.php Changeable - показывает где дерриктива может быть изменена
//можно исплльзовать ф-ции
// ini_get()
// ini_set()
//для получения и изменения дирректив
//Но некотрые диррективи невозможно изменить во время выполнения программы, а только в файле INI
//INI_SYSTEM - нельзя использовать ini_set() для изменения диррективы
//INI_PERDIR  - нельзя использовать ini_set() для изменения диррективы
// ini_set() -меняет значение диррективы во ввремя выполнения - это эффективно только во время выполнения программы
//Примечание: однажды изменив свой ПХП ИНИ  возможно надо будет перезапустить апач сервер для вступления в силу

//error_reporting errror_log display_errors
//error_reporting - позволяет установить разные уровни доклада об ошибках ПХП
//error_reporting              = E_ALL & ~E_NOTICE
//E_ALL  - доклады будут вестись  ов сех ошибках и предупреждениях
var_dump(ini_get('error_reporting'));//"32759" - константа соответсвующая E_ALL
$array = [1];
//echo $array[3];//Warning
//можем измениить эррор репотинг для игнорирования этого варнинга - ЧТО НЕ РЕКОМЕНДУКЕТСЯ АВТОРОМ,  так как это позволяет исправлять баги
//ini_set('error_reporting', E_ALL & ~E_WARNING);//& ~ - это является побитовым оператором, что было в предыдцущих уроках // теперь ошибки не будет
//echo $array[3];////Warning больше нет
//Примечание: также модно устанеовить Э_Р как error_reporting function - но об этоми позже

//display_errors -показывает выводить ли ошибки на экран или нет
var_dump(ini_get('display_errors'));//string(1) "1"
// ini_set ('display_errors', 0);// теперь ошибки не будет, но  ошибки будут логироваться
//echo $array[3];//Warning

//error_log - показывает где ошибка должна быть логирована

//post_max_size - мы не говорили о формах или размещение данных, но эта установка определяет сколько данных может быть размещено  в запросе
//max_execution_time - установка максимального кол-ва секунд, которое скрипть может выполняться, до того как его время выйдет и будет прекращено, по дефолту это 30 сек

// ini_set('max_execution_time', 3);
// sleep(5);
// echo 'Hello World';//Fatal error

//memory_limit - установка максимальной памяти, к-рую  скрипт может потребить
var_dump(ini_get('memory_limit'));

// $string = 'X';
// for ($i = 0; $i < 1000; $i++) {
//     $string .= $string;
// }

// echo $string;//Fatal error  Allowed memory size of 1610612736 bytes exhausted
//установка  memory_limit -1 убирает лимит  совсем, но автор не советует так делать т к луше оптимизировать свой код, что бы видеть сколько памяти потребил код

//file_uploads - делает доступним или не доступным файл загрузки в ПХП, с file_uploads связан upload_tmp_dir
//upload_tmp_dir - показывает папку темп - где будут храниться файлы тэмп, когда происходит загрузка файлов
//также есть upload_max_filesize
//date.timezone
//include_path - упоминали прежде в уроках - указывает список дирректорий, где reqire, include,  reqire once, include once и другие ф-ции к-рые имеют дело с открытием файлов, будут искать файлы по дефолту

//1.28 Error Handing
//error_reporting(0); // выключает оповещения обо всех ошибках
//(E_ALL)// вкл.чает оповещения   обо всем в том числе и о предупреждениях 
//(~E_Warning) - исключает выведение предупреждений - НЕ РЕКОМЕНДУЕТСЯ АВТОРОМ
//Есть также константы: 
//E_USER_WARNING
//E_USER_ERROR и т д - они генерируются вручную триггером ф-цией вызова ошибок:
/*trigger_error('Example error', E_USER_ERROR);// Первый аргумент -  сообщение, второй аргумент - уровень ошиибки// Fatal error: Example error  - скрипт остановлен
echo 1;
*/
/*trigger_error('Example error', E_USER_WARNING);//Warning: Example error -  скрипт не остановелн
echo 1;*/
//Возможно использовать только Е_USER константы когда вызываем ошибки вручную, нельзя вызвать обычную напр E_WARNING
//В случае ошибки в ПХП, ПХП определит должна ли выводится ошибка используя директиву
//display_errors - следует выключать ее для избежания потери чувствительной инфорамации о внутренних ошибках
// эти ошибки будут логироваться в файл, даже когда не выводятся, пока включен error_log - локация к -рого зависит от нескольких вещей
//Также можно вручную логировать ошибки используя ф-цию
//error_log();//( string $message - сообщение бодет логироваться в этот файл [, int $message_type = 0 [, string $destination [, string $extra_headers ]]])
//Как обработать ошибку во время выполнения кода- собственноручно написанным обработчиком. Что дает силу навтроить твои нужды. Создадим ф-цию:
function errorHandler(
    int $type, 
    string $msg, 
    ?string $file = null,
    ?int $line = null)// (тип ошибки, сообщение), опционально можно исключить файл и номер строки где  ошибка произошла
    {
        echo $type . ': '. $msg. 'in' .$file. 'on line' .$line;// - такое не выводится в реальной жизщни, тк тип цели пользовательских обработчиков, тк.к ты не хочешь обличать ошибки перед пользователем, но если ты хочешь только напечатать обработчик ошибок - это не принесет решение проблемы, но здесь мы это сделаем для демонстрации 
        return;// можно вернуть фолс для окатат назад обработчика или тру для продолжения выполнения кода
        exit;// для остановки выполннгения
    }
    error_reporting(E_ALL & ~E_WARNING);
    //вызовем ошибку
   // echo $h; // здесь предупрежд не показывается
    //зарегистрируем обработчик ошибок ф-цией
    set_error_handler('errorHandler', E_ALL);//( callable $error_handler [, int $error_types = E_ALL - область на которую распространяется регистрируемый обработчик ошибок | E_STRICT ])
    //этот обработчик будет перезаписиывать что либо, что ты установил  в error_reporting
    //напр если до этого было error_reporting(E_ALL & ~E_WARNING) - c исключением предупрежений то теберь будет распростаранятся на все

   echo $h; // здесь преджупр показывается
//Осторожно ! некоторые типы ошибок напр parse compile не могут быть обработаны
//echo $h// parse error - также если эта ошибка произошла до того как скрипт имел шанс выполниться  к точке где регистрировали обработчик, ты не обработаешь пользовательским обработчиком

//И наколнец ты можешь востановить предыдущий обработчик ошибок вызовом error_handler ф-ции
//про обоработчик ошибок  - это были лишь основы