<?php
declare(strict_types=1);

//1.20  Include & require file in PHP
//require - При ошибке прекращает выполнение скрипта
//require 'file.php';

//require_once  -  подключает файл только один раз
/*
require_once 'file.php';
$x++;
echo $x. "\n";//6
require_once 'file.php';// второй раз файл не подключается
echo $x. "\n";//6
*/


//include  ПРи ошибке выдает предупреждение и продолжает выполнение скрипта
//include 'file.php';//подключает файл с указанием пути до него.

//include_once   подключает файл только один раз
echo 'Hello world' . "\n";

//Лучше всего использовать include и require для возможности повторного использоывания кода и его структурирования, и для случаев кгда возвращаешь чего нитиь из подключенных файлов

$x = 5;
$y = include 'file.php';
echo $x ."\n";
var_dump($y);// int(1)

// $y = include 'filerreds.php';
// echo $x ."\n"; //6
// var_dump($y);//false


// $nav = include './partials/nav.php';
// var_dump($nav);//int(1)
//если требуется преобразовать контент присоединяемого  хтмл файлва в строку:
ob_start();
include './partials/nav.php';
$nav = ob_get_clean();
//var_dump($nav);//string(151)
$nav = str_replace('About', 'Abuot Us', $nav);
echo $nav;

//1.21 Functions & type hints
echo "\n";
function foo(){
    echo 'Hello World'. "\n";
}
foo();

function foo1(){
    return 'Hello World'. "\n";
}
echo foo1();

function foo2(){
    return;
}
echo foo2();
var_dump(foo2());// NULL

//Можно определить ф-цию и после вызова:
var_dump (foo3());
function foo3(){
    return 'Hello World3'. "\n";
}//ф-цию можно определить где угодно относительно вызова - оа всегда будет загружена раньше, чем пхп ее использует так долго  до  тех пор пока загружена функция в скрипт который ее вызвал. Есть пару исключений:
//Сначала необходимо определить ф-цию, а потом вызвать : 
//1 Если мы определили ф-цию в условии:

// var_dump (foo4());

// if(false) {
//     function foo4() {
//         return 'Hello World3'. "\n";
//     }
// }

//2. Если определяем ф-цию внутри другой ф-ции, без вызова внешней ф-ции не может быть вызвана внутренняя ф-ция -будет ошибка. Т к запуск внешней ф-ции в данном случае определяет объявление внутренней ф-ции.

foo5();
bar();

function foo5()
{
    echo 'Foo';
    function bar() {
        echo "Bar" ."\n";
    }
}

//НЕ РЕКОМЕНДУЕТСЯ ОБЪЯВЛЯТЬ Ф-ЦИЮ В УСЛОВИЯХ ИЛИ ВНУТРИ ДРУГОЙ Ф-ЦИИ - ТРУДНЕЕ ЧИТАТЬ
//нельзя повторять имя ф-ции - будет ошибка

//Return types

//you able to type hint the return value

function foo6() {// здесь не указываем какой тип данных ожидаем к возврату
    return 1;
}
var_dump(foo6());//int(1) - пхп вычиляет автоматически

function foo7(): int {//указываем тип данных который ожидаем к возврату
    return 1;
    // return '1';// -   в строгом режиме выдаст ошибку, в нестрогом режиме пхп будет пытаться преобразовать в указанный нами тип данных
   // return[];// выдаст ошибку в любом режиме, т.к невозможно массив преобразовать в инт.
}
var_dump(foo7());//int(1)

// function foo8(): string {//указываем тип данных который ожидаем к возврату
//     return 1;//в нестрогом режиме пхп будет пытаться преобразовать в указанный нами тип данных
// }
// var_dump(foo8());

//Если ожидаем что нечего возвращать, то type hint - void:
function foo9(): void {
    return;
}
var_dump(foo9());//NULL


function foo10(): void {
    //return null;//выдаст ошибку, т к null - это все-таки тип данных, а void говорит, что мы ниего не ожидаем к возврату
}
var_dump(foo10());

//если в некоторых случаях ожидаем инт, а в некотрых НУЛЛ, то используем оператор ?
function foo11(): ?int {
    return null; // работает в обоих случаях
    //return 1;// работает в обоих случаях

}
var_dump(foo11());


//Если ожидаем несколько типов данных
function foo12(): int|float|array {
    return [1.5]; 
}
var_dump(foo12());

//или можно использовать mixed

function foo13(): mixed {
    return null; 
}
var_dump(foo13());

//автору не нравится исп-е миксд, тк  предпочитает указаниеопреденных типов, но есть полезный случай для миксд:
// если ожидается тип, который не может быть зазначен type hint
// также т к миксд поразумевает в т ч НУЛЛ, то мы не можеи использовать знак ?

//также  как и для возвращаемого значения, type hint может указываться и для параметров ф-ции

//1.22 Function Parametrs

function foo14($x, $y) {//здесь в скобках параметры
    return $x * $y . "\n";
}
echo foo14(5, 10); // здесь в скобках аргументы

//также  как и для возвращаемого значения, type hint может указываться и для параметров ф-ции
// 
function foo15( int|float $x,int|float $y) {//здесь в скобках параметры
    return $x * $y . "\n";
}
echo foo15(5.0, 10);

//Рекомендуется использовать строгий режим ,тк. в это случае мы точно знаем какие аргументы ожидаются и какой тип данных ожидается к возврату, в особенности если hint - содержит несколько типов, т.к. это может повлиять на результат вычислений

//Для каждого параметра необхобимо вставлятьь аргумент иначе будет ОШИБКА, но его можно вставить и при объявлении ф-ции(по дефолту)
function foo16( int|float $x,int|float $y = 12) {//здесь в скобках параметры
    return $x * $y . "\n";
}
echo foo16(5.0);

//В параметрах по дефолту могут быть численный массив, значение НУЛЛ. В параметрах  не может быть вызова ф-ции, не может быть объекта или константы. Также дефолтное объявление должно идти после всех остальных параметров:

// function foo17( int|float $x,int|float $y = 12, int $z) { - иначе будет ОШИБКА
//     return $x * $y/$z . "\n";
// }
// echo foo17(5.0, 6);

//Обычно аргументам передаются значения, но можно изменить это и указать передачу по ссылке:
function foo18( int|float $x,int|float $y): int|float {
   if ($x % 2 === 0){
    $x /= 2;
   }
    return $x * $y;
}

$a = 6.0;
$b = 7;
echo foo18($a, $b). "\n";// 21 - здесь переменной а  присваивается значение 6, несмотря на то что в строке 189  х=3
var_dump($a, $b);//6 , 7
//теперь добавим знак & (назначим по ссылке)
function foo19( int|float &$x,int|float $y): int|float {//& - значит что мы передаем здесь аргумент по ссылке
    if ($x % 2 === 0){
     $x /= 2;
    }
     return $x * $y;
 }
 
 $a = 6.0;
 $b = 7;
 echo foo19($a, $b). "\n";// 21 - теперь , когда мы передаем а, вместо передачи значения 6(шесть), мы передаем ссылку в переменную а
 var_dump($a, $b);//3 , 7, а =3, т.к. мы преобразовали переменную в теле функции

 //Variadic function - принимающая вариативное количество аргументов

 function sum(...$numbers): int|float {//вместо использования множества параметров, можно использовать сплат оператор, который будет включать в себя аргументы переданные в ф-цию в массив и numbers будет тем массивом, содержащим все эти аргументы
    //можно проводить итерации над этим массивом
    // $sum = 0;
    // foreach($numbers as $number) {
    //     $sum += $number;
    // }
    // return $sum;
    return array_sum($numbers);// то же самое, что и выше
 }

 $a = 6.0;
 $b = 7;

 echo sum($a, $b, 50, 100, 25, 8, 9) . "\n";// при добавлениее неограниченного кол-ва аргуиентов нужно использовать splat-оператор

 //слпат оператор может использоваться после параметров, в этом случае, только аргументы переданные после этого будут добавлены в массив. Задаем Х и У и только после этого захъватываем остальные аргументы  сплат-оператором
 function foo20( int|float $x, int|float $y, ...$numbers): int|float { // в этом случае x=a, y=b, а все остальное будет захвачено в массив - в жизни такая практика невстречается

    return $x + $y + array_sum($numbers);
 }

 $a = 6.0;
 $b = 7;

 echo sum($a, $b, 50, 100, 25, 8, 9) . "\n";

// мы также можем указать ожидаемый тип данных  для всех аргументов, которые были переданы
function foo21( int|float $x, int|float $y, int|float ...$numbers): int|float { 

    return $x + $y + array_sum($numbers);
 }

 $a = 6.0;
 $b = 7;

 //echo sum($a, $b, 50, '100', '25', 8, 9) . "\n";// ошибки не будет до указания type hint у...$numbers 
 echo sum($a, $b, 50, 100, 25, 8, 9) . "\n";
 //Нельзя ли исползовать массив и принимать один параметр как массив и перердавать эти аргументы как элементы внутри массива? - ответ - можно, но сплат оператор позволяет тебе определить типы каждого  элемента, а в  массиве ты не можешь определить тип. 
 //Сплат оператор также можно тиспользовать для распаковки массива в список аргументов
 function sum1( int|float $x, int|float $y, int|float ...$numbers): int|float { 

    return $x + $y + array_sum($numbers);
 }

 $a = 6.0;
 $b = 7;
 $numbers = [50, 100, 25.90, 8, 9];

 //echo sum1($a, $b, $numbers) . "\n";// Ошибка т.к аргуметы д б  инт/флоат, а здесь масив
 echo sum1($a, $b, ...$numbers) . "\n";//исползуем сплат для разбиения массива на аргшументы - ошибки нет. сплат - неоффициальное название, также оператор может называться оператор многоточия и  оператор распоковки и прочее

 //Named arguments - апозволяю передать аргументы в функцию основанной на параметре имени переменной, что означает, что они не обязательно должны быть в определенном порядке
 
 function foo22(int $x, int $y): int {
    if ($x % $y === 0) {
        return $x / $y;
    }
    return $x;
 }

 $x = 6;
 $y = 3;

 //echo foo22($x, $y);//2
 //но что если мы перепутаем порядок:
 //echo foo22($y, $x);//3 - неверно
 //используем именнованные аргументы
 echo foo22(y: $y, x: $x). "\n";//2 - теперь порядок неважен
 //Теперь если вам нужно изменить порядок параметров определения в ф-ции, нет необходимости искать где эта ф-ция используется в коде и корректировать упорядоченность аргументов. Однако если изменено имя параметра, то необходимо будет вкоде искать и изменять его имя, т.к. в таком случае именнованые аргументы не будут совпадать с параметрами.

 //Если есть куча параметров со значением по дефолту  и нужно заполнить первые два и самый последний,
 //setcookie('foo', 'bar', 0, '', '', false, true);// то необходимо заполнить каждый аргумент до этого последнего
 //setcookie(name: 'foo', value: 'bar',httponly: true);// C именнованными аргументаи их можно пропустить,  и если далее по коду пропущенные параметры изменят значение, то не нужно их искать и менять  в предыдущих строках кода

 // Если передавать один параметр несколько раз то будет перезапись параметра и ошибка

 //echo foo22(x: $y, x: $x);
 echo foo22( $x, y: $x) . "\n";// можно скомбинировать именнованный  с неименнованым
 //echo foo22( $x, x: $y);// снова будет ошибка

 //Если использовать распаковку аргументов, если массив являеися ассоциативным, тогда ключи будут обработаны как  имена аргументов
 function foo23(int $x, int $y): int {
    var_dump($x, $y);
    if ($x % $y === 0) {
        return $x / $y ;
    }
    return $x ;
 }
 $arr = ['x' => 1, 'y' => 2];//int(1)  int(2) - т.е  все равно что именнованные аргументы х: 1, у: 2

 echo foo23(...$arr) . "\n";

 $arr = ['y' => 2, 'x' => 1];//int(1)  int(2) - и  при изменении порядка результат тот же

 echo foo23(...$arr) . "\n";

 //Неассоциативные элементы будут обработаны как позиционные аргументы

 $arr = [2, 'x' => 1];// так, что если убрать первый ключ, то 2 будет передана в параметр х и затем снова в х - ОШИБКА

 